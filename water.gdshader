// Generated by GROK

shader_type spatial;
render_mode blend_mix, depth_draw_opaque, cull_back, diffuse_lambert, specular_schlick_ggx;

// Uniforms for customization
uniform float wave_speed = 1.0;
uniform float wave_height = 0.05;
uniform float wave_frequency = 2.0;
uniform vec3 water_color = vec3(0.0, 0.4, 0.7);
uniform float transparency = 0.85;
uniform float details_thickness = 0.02; // Thickness of the detail outlines
uniform float details_intensity = 0.7; // Brightness of the details
uniform float details_density = 4.0; // Density of the detail pattern (higher = more details)
uniform float details_randomness = 0.5; // Randomness in the pattern (0.0 = uniform, 1.0 = chaotic)
uniform float noise_scale = 3.0;
uniform float noise_strength = 0.15;

// Smooth noise function
float smooth_noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    vec2 u = f * f * (3.0 - 2.0 * f);
    float a = fract(sin(dot(i, vec2(127.1, 311.7))) * 43758.5453);
    float b = fract(sin(dot(i + vec2(1.0, 0.0), vec2(127.1, 311.7))) * 43758.5453);
    float c = fract(sin(dot(i + vec2(0.0, 1.0), vec2(127.1, 311.7))) * 43758.5453);
    float d = fract(sin(dot(i + vec2(1.0, 1.0), vec2(127.1, 311.7))) * 43758.5453);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Layered noise for ripples
float layered_noise(vec2 uv) {
    float n = 0.0;
    n += smooth_noise(uv * noise_scale) * 0.5;
    n += smooth_noise(uv * noise_scale * 2.0 + vec2(TIME * 0.02)) * 0.25;
    return n / (0.75);
}

// New details effect using noise-based distance field
float details_pattern(vec2 uv) {
    vec2 scaled_uv = uv * details_density + TIME * 0.05;
    float n1 = smooth_noise(scaled_uv + vec2(13.7, 19.3)); // Base noise
    float n2 = smooth_noise(scaled_uv * 1.5 + vec2(TIME * 0.03, -TIME * 0.02)); // Secondary noise for variation
    float rand = mix(0.5, n1 * n2, details_randomness); // Randomness factor

    // Create wavy distance field
    float wave = sin(scaled_uv.x * 3.0 + n1 * 6.28 + TIME * 0.1) + cos(scaled_uv.y * 3.0 + n2 * 6.28 + TIME * 0.1);
    float dist = abs(wave + rand * 2.0 - 1.0); // Distance field with randomness

    // Outline effect
    float outline = smoothstep(details_thickness, 0.0, dist) * smoothstep(0.0, details_thickness * 2.0, dist);
    return outline;
}

// Vertex function
void vertex() {
    float wave1 = sin(TIME * wave_speed + VERTEX.x * wave_frequency + VERTEX.z * wave_frequency) * wave_height;
    float wave2 = sin(TIME * wave_speed * 0.7 + VERTEX.z * wave_frequency * 1.2 + VERTEX.x * 0.8) * wave_height * 0.8;
    float noise_val = layered_noise(VERTEX.xz * 0.5 + TIME * 0.05) * wave_height * 0.2;
    VERTEX.y += (wave1 + wave2 + noise_val) * 0.5;
}

// Fragment function with new details effect
void fragment() {
    // Base water color with noise
    float noise_val = layered_noise(UV * noise_scale + TIME * 0.02);
    vec3 base_color = water_color * (0.8 + noise_val * noise_strength);

    // Generate new details pattern
    float detail_mask = details_pattern(UV);

    // Blend details with base color
    vec3 final_color = mix(base_color, vec3(0.9, 0.95, 1.0), detail_mask * details_intensity);

    // Normal perturbation
    vec2 time_offset = vec2(TIME * wave_speed * 0.1, TIME * wave_speed * 0.07);
    float normal_noise = layered_noise(UV * noise_scale) * 0.1;
    vec3 normal = normalize(vec3(
        sin(UV.x * wave_frequency + time_offset.x + normal_noise) * 0.3,
        1.0,
        sin(UV.y * wave_frequency + time_offset.y + normal_noise) * 0.3
    ));
    NORMAL = normal;

    // Albedo and transparency
    ALBEDO = final_color;
    ALPHA = transparency;

    // Specular and roughness
    SPECULAR = 0.4;
    ROUGHNESS = 0.3;
}

// Light function
void light() {
    DIFFUSE_LIGHT = ALBEDO * max(0.0, dot(NORMAL, LIGHT));
    vec3 half_vec = normalize(LIGHT + VIEW);
    float spec = pow(max(0.0, dot(NORMAL, half_vec)), 16.0);
    SPECULAR_LIGHT = vec3(spec) * 0.3;
}